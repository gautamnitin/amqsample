 Functional Requirements Document
Title: Customer Financial Snapshot Publisher – Integration with XYZ API and ActiveMQ Artemis
Author: Nitin Gautam
Date: July 27, 2025
1. 📌 Objective
To ingest customer financial data from XYZ’s API—covering account details, institution connections, and transactions—and publish a normalized, canonical JSON payload to ActiveMQ Artemis for downstream analytics, enrichment, or compliance workflows.

2. 🚀 Scope
This solution covers:
- Integration with XYZ’s RESTful APIs using Spring Boot
- Retrieval of account, transaction, and connection data per customer
- Transformation into a canonical data model
- JSON serialization and message publication to ActiveMQ Artemis queue
- Triggering via REST API or scheduled daily job

3. 🔧 Functional Requirements
3.1 XYZ API Integration
- Authenticate via OAuth 2.0 Client Credentials Flow
- Fetch per-customer:
- /users/{userId}/accounts
- /users/{userId}/connections
- /users/{userId}/accounts/{accountId}/transactions?date=YYYY-MM-DD
3.2 Canonical Payload Structure
- Header Section: message metadata (ID, timestamp, source, region)
- Payload Section: customer identity, accounts, connections, transactions, tags
3.3 Message Publication
- Serialize using Jackson ObjectMapper
- Publish to queue.customer-financial-update
- Attach message headers: customerId, eventType, timestamp
3.4 REST Trigger
- Endpoint: POST /publish
- Accepts JSON payload conforming to canonical schema
- Produces success/failure response

4. 💼 Non-Functional Requirements
- 💻 Technology Stack: Java 17, Spring Boot, ActiveMQ Artemis
- 🔐 Security: API secrets managed via application.yml or Vault
- 📈 Scalability: Modular design to extend for Kafka or file sync
- 🧪 Testability: Unit and integration tests for POJOs and message flow
- ⏱ Scheduling: @Scheduled job for daily sync (optional)

5. 🔗 External Dependencies
- XYZ Developer API (access tokens & credentials required)
- ActiveMQ Artemis broker
- Internal downstream consumers (e.g. risk engines, data lake, reporting)

6. 📊 Sample Payload Format
Canonical JSON posted to ActiveMQ Artemis includes both header and payload sections (see previous message for full schema).

🧭 Solution Overview
🧱 Architecture Flow
+----------------+        +-------------------+        +---------------------+
| XYZ API     |  --->  | Spring Boot Layer |  --->  | ActiveMQ Artemis    |
| (customer data)|        | (transform & push)|        | (queue: financial)  |
+----------------+        +-------------------+        +---------------------+
         ↑                         ↑                            ↑
     Scheduler              REST Controller               Downstream Consumers


🔄 Process Breakdown
- API Ingestion
- Auth via OAuth 2.0
- Retrieve accounts, connections, transactions
- Filter daily transactions (optional query param)
- Canonical Transformation
- Populate CustomerFinancialMessage POJO
- Include structured header for traceability
- Message Publication
- Serialize to JSON
- Publish to ActiveMQ queue
- Attach JMS properties for routing
- Triggering Modes
- Manual via /publish endpoint
- Automated via scheduled job (@Scheduled)

I can generate slides or diagrams if you want to enhance your team presentation. Would you like a one-pager, pitch deck, or demo outline next? Let’s make this easy for stakeholders to align with.


Absolutely, Nitin. The Canonical Transformation Layer is the strategic linchpin of your architecture—it ensures data consistency, semantic clarity, and downstream agility. Here’s a detailed breakdown of its role and value across the data lifecycle:

🔄 Canonical Transformation Layer – Deep Dive
🎯 Core Purpose
To standardize diverse customer financial data (from APIs like XYZ) into a unified, internally agreed-upon canonical model—structured, reusable, and future-proof.

🧩 Why It's Critical
| Aspect | Value | 
| Data Uniformity | Converts heterogeneous schemas into a predictable format | 
| Interoperability | Enables seamless integration with multiple consumers (risk, BI, etc.) | 
| Decoupling | Shields consumers from upstream schema volatility | 
| Auditability | Embeds metadata for traceability and versioning | 
| Extensibility | Easily accommodates new fields/sources without breaking consumers | 



🛠️ Transformation Workflow
Here’s how the canonicalization unfolds step-by-step:
- Raw Data Retrieval
- Fetches from XYZ endpoints (/accounts, /connections, /transactions)
- Each API may use different naming conventions, structures, or nested hierarchies
- Semantic Normalization
- Translates raw fields to domain terms
- acctBalance → currentBalance
- connStatus → status
- Resolves inconsistencies like date formats, currency representation, enums
- Canonical Model Construction
- Uses typed POJOs like CustomerFinancialMessage
- Structured into:
- Header: metadata for routing and observability
- Payload: nested objects for accounts, connections, transactions, tags
- Example:
class CustomerFinancialMessage {
    Header header;
    Payload payload;
}
- Serialization & Message Enrichment
- Serialized to JSON using Jackson or Gson
- Optionally enriched with:
- Correlation IDs
- Tags (verified, reconciled, source:XYZ)
- Transformation version (v1.2)

🔍 Canonical Schema Snapshot
{
  "header": {
    "messageId": "uuid-1234",
    "timestamp": "2025-07-27T18:23:00Z",
    "source": "XYZ",
    "region": "US-East"
  },
  "payload": {
    "customerId": "C789",
    "accounts": [ { ... } ],
    "connections": [ { ... } ],
    "transactions": [ { ... } ],
    "tags": ["verified", "daily-sync"]
  }
}



🧠 Business Benefits
- 🧮 Clear semantics empower analytics teams to write resilient queries
- 🔄 Versioned schemas enable safe evolution over time
- 🔐 Embedded metadata supports compliance audits
- 🧩 Pluggable design opens doors to ingest new sources (e.g. Plaid, Yodlee) without retooling consumers

Would you like a code sample of the POJO and mapper class next? Or a visual schema map showing how raw XYZ fields align to your canonical structure? I can prep either for your team walkthrough.
